{
  "name": "chat-message-area",
  "type": "registry:ui",
  "registryDependencies": [
    "scroll-area",
    "button"
  ],
  "files": [
    {
      "path": "ui/chat-message-area.tsx",
      "content": "import { Button } from \"@/components/ui/button\";\nimport { ScrollArea } from \"@/components/ui/scroll-area\";\nimport { cn } from \"@/lib/utils\";\nimport { useScrollToBottom } from \"@/hooks/use-scroll-to-bottom\";\nimport { ChevronDown } from \"lucide-react\";\nimport type { ReactNode } from \"react\";\n\ntype ScrollButtonAlignment = \"left\" | \"center\" | \"right\";\n\ninterface ScrollButtonProps {\n\tonClick: () => void;\n\talignment?: ScrollButtonAlignment;\n\tclassName?: string;\n}\n\nexport function ScrollButton({\n\tonClick,\n\talignment = \"right\",\n\tclassName,\n}: ScrollButtonProps) {\n\tconst alignmentClasses = {\n\t\tleft: \"left-4\",\n\t\tcenter: \"left-1/2 -translate-x-1/2\",\n\t\tright: \"right-4\",\n\t};\n\n\treturn (\n\t\t<Button\n\t\t\tvariant=\"secondary\"\n\t\t\tsize=\"icon\"\n\t\t\tclassName={cn(\n\t\t\t\t\"absolute bottom-4 rounded-full shadow-lg hover:bg-secondary\",\n\t\t\t\talignmentClasses[alignment],\n\t\t\t\tclassName,\n\t\t\t)}\n\t\t\tonClick={onClick}\n\t\t>\n\t\t\t<ChevronDown className=\"h-4 w-4\" />\n\t\t</Button>\n\t);\n}\n\ninterface ChatMessageAreaProps {\n\tchildren: ReactNode;\n\tclassName?: string;\n\tscrollButtonAlignment?: ScrollButtonAlignment;\n}\n\nexport function ChatMessageArea({\n\tchildren,\n\tclassName,\n\tscrollButtonAlignment = \"right\",\n}: ChatMessageAreaProps) {\n\tconst [\n\t\tcontainerRef,\n\t\tmessagesEndRef,\n\t\tshowScrollButton,\n\t\tscrollToBottom,\n\t] = useScrollToBottom<HTMLDivElement>();\n\n\treturn (\n\t\t<ScrollArea className=\"flex-1 relative\">\n\t\t\t<div ref={containerRef}>\n\t\t\t\t<div className={cn(className, \"min-h-0\")}>{children}</div>\n\t\t\t\t<div\n\t\t\t\t\tref={messagesEndRef}\n\t\t\t\t\t\tclassName=\"shrink-0 min-w-[24px] min-h-[4px]\"\n\t\t\t\t/>\n\t\t\t</div>\n\t\t\t{showScrollButton && (\n\t\t\t\t<ScrollButton\n\t\t\t\t\tonClick={scrollToBottom}\n\t\t\t\t\talignment={scrollButtonAlignment}\n\t\t\t\t\tclassName=\"absolute bottom-4 rounded-full shadow-lg hover:bg-secondary\"\n\t\t\t\t/>\n\t\t\t)}\n\t\t</ScrollArea>\n\t);\n}\n\nChatMessageArea.displayName = \"ChatMessageArea\";\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "hooks/use-scroll-to-bottom.ts",
      "content": "import { type RefObject, useCallback, useEffect, useRef, useState } from \"react\";\n\nexport function useScrollToBottom<T extends HTMLElement>(): [\n\tRefObject<T>,\n\tRefObject<T>,\n\tboolean,\n\t() => void,\n] {\n\tconst containerRef = useRef<T>(null);\n\tconst endRef = useRef<T>(null);\n\tconst [shouldAutoScroll, setShouldAutoScroll] = useState(true);\n\tconst [showScrollButton, setShowScrollButton] = useState(false);\n\tconst [isTouching, setIsTouching] = useState(false);\n\tconst isManualScrolling = useRef(false);\n\tconst lastScrollTop = useRef(0);\n\tconst smoothScrollTimeout = useRef<number>();\n\n\tconst getViewport = useCallback((element: HTMLElement | null) => {\n\t\treturn element?.closest(\"[data-radix-scroll-area-viewport]\") as HTMLElement;\n\t}, []);\n\n\tconst checkIfShouldShowButton = useCallback((viewport: HTMLElement) => {\n\t\tconst { scrollTop, scrollHeight, clientHeight } = viewport;\n\t\tconst isAtBottom = Math.abs(scrollHeight - scrollTop - clientHeight) < 10;\n\t\tconst hasScrollableContent = scrollHeight > clientHeight;\n\n\t\tsetShowScrollButton(hasScrollableContent && !isAtBottom);\n\t\tsetShouldAutoScroll(isAtBottom);\n\t}, []);\n\n\tuseEffect(() => {\n\t\tconst container = containerRef.current;\n\t\tconst viewport = getViewport(container);\n\t\tconst end = endRef.current;\n\n\t\tif (container && viewport && end) {\n\t\t\t// Initial check for scroll button\n\t\t\tcheckIfShouldShowButton(viewport);\n\n\t\t\tconst handleScroll = () => {\n\t\t\t\tif (isManualScrolling.current || isTouching) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst { scrollTop } = viewport;\n\t\t\t\tlastScrollTop.current = scrollTop;\n\t\t\t\tcheckIfShouldShowButton(viewport);\n\t\t\t};\n\n\t\t\tconst handleTouchStart = () => {\n\t\t\t\tsetIsTouching(true);\n\t\t\t};\n\t\t\t\n\t\t\tconst handleTouchEnd = () => {\n\t\t\t\tsetIsTouching(false);\n\t\t\t};\n\n\t\t\t// Content change observer\n\t\t\tconst mutationObserver = new MutationObserver(() => {\n\t\t\t\tif (shouldAutoScroll && !isTouching) {\n\t\t\t\t\tisManualScrolling.current = true;\n\t\t\t\t\tviewport.scrollTo({\n\t\t\t\t\t\ttop: viewport.scrollHeight,\n\t\t\t\t\t\tbehavior: \"instant\",\n\t\t\t\t\t});\n\t\t\t\t\trequestAnimationFrame(() => {\n\t\t\t\t\t\tisManualScrolling.current = false;\n\t\t\t\t\t\tcheckIfShouldShowButton(viewport);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tcheckIfShouldShowButton(viewport);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tviewport.addEventListener(\"scroll\", handleScroll, { passive: true });\n\t\t\tviewport.addEventListener(\"touchstart\", handleTouchStart);\n\t\t\tviewport.addEventListener(\"touchend\", handleTouchEnd);\n\n\t\t\tmutationObserver.observe(container, {\n\t\t\t\tchildList: true,\n\t\t\t\tsubtree: true,\n\t\t\t\tattributes: true,\n\t\t\t\tcharacterData: true,\n\t\t\t});\n\n\t\t\treturn () => {\n\t\t\t\tif (smoothScrollTimeout.current) {\n\t\t\t\t\twindow.clearTimeout(smoothScrollTimeout.current);\n\t\t\t\t}\n\t\t\t\tmutationObserver.disconnect();\n\t\t\t\tviewport.removeEventListener(\"scroll\", handleScroll);\n\t\t\t\tviewport.removeEventListener(\"touchstart\", handleTouchStart);\n\t\t\t\tviewport.removeEventListener(\"touchend\", handleTouchEnd);\n\t\t\t};\n\t\t}\n\t}, [shouldAutoScroll, isTouching, getViewport, checkIfShouldShowButton]);\n\n\tconst scrollToBottom = () => {\n\t\tconst container = containerRef.current;\n\t\tconst viewport = getViewport(container);\n\t\t\n\t\tif (viewport) {\n\t\t\t// Clear any existing smooth scroll timeout\n\t\t\tif (smoothScrollTimeout.current) {\n\t\t\t\twindow.clearTimeout(smoothScrollTimeout.current);\n\t\t\t}\n\n\t\t\tisManualScrolling.current = true;\n\t\t\t\n\t\t\t// Do the smooth scroll\n\t\t\tviewport.scrollTo({\n\t\t\t\ttop: viewport.scrollHeight,\n\t\t\t\tbehavior: \"smooth\",\n\t\t\t});\n\n\t\t\t// Wait for the smooth scroll to finish (approximately)\n\t\t\t// and then enable auto-scroll\n\t\t\tsmoothScrollTimeout.current = window.setTimeout(() => {\n\t\t\t\tisManualScrolling.current = false;\n\t\t\t\tsetShouldAutoScroll(true);\n\t\t\t\tsetShowScrollButton(false);\n\t\t\t}, 500); // 500ms should be enough for most smooth scrolls\n\t\t}\n\t};\n\n\treturn [containerRef, endRef, showScrollButton, scrollToBottom];\n}\n",
      "type": "registry:hook",
      "target": ""
    }
  ]
}