{
  "name": "chat-message-area",
  "type": "registry:ui",
  "registryDependencies": [
    "scroll-area",
    "button"
  ],
  "files": [
    {
      "path": "ui/chat-message-area.tsx",
      "content": "import { Button } from \"@/components/ui/button\";\nimport { ScrollArea } from \"@/components/ui/scroll-area\";\nimport { cn } from \"@/lib/utils\";\nimport { useScrollToBottom } from \"@/hooks/use-scroll-to-bottom\";\nimport { ChevronDown } from \"lucide-react\";\nimport type { ReactNode } from \"react\";\n\ntype ScrollButtonAlignment = \"left\" | \"center\" | \"right\";\n\ninterface ScrollButtonProps {\n\tonClick: () => void;\n\talignment?: ScrollButtonAlignment;\n\tclassName?: string;\n}\n\nexport function ScrollButton({\n\tonClick,\n\talignment = \"right\",\n\tclassName,\n}: ScrollButtonProps) {\n\tconst alignmentClasses = {\n\t\tleft: \"left-4\",\n\t\tcenter: \"left-1/2 -translate-x-1/2\",\n\t\tright: \"right-4\",\n\t};\n\n\treturn (\n\t\t<Button\n\t\t\tvariant=\"secondary\"\n\t\t\tsize=\"icon\"\n\t\t\tclassName={cn(\n\t\t\t\t\"absolute bottom-4 rounded-full shadow-lg hover:bg-secondary\",\n\t\t\t\talignmentClasses[alignment],\n\t\t\t\tclassName,\n\t\t\t)}\n\t\t\tonClick={onClick}\n\t\t>\n\t\t\t<ChevronDown className=\"h-4 w-4\" />\n\t\t</Button>\n\t);\n}\n\ninterface ChatMessageAreaProps {\n\tchildren: ReactNode;\n\tclassName?: string;\n\tscrollButtonAlignment?: ScrollButtonAlignment;\n}\n\nexport function ChatMessageArea({\n\tchildren,\n\tclassName,\n\tscrollButtonAlignment = \"right\",\n}: ChatMessageAreaProps) {\n\tconst [\n\t\tmessagesContainerRef,\n\t\tmessagesEndRef,\n\t\tshowScrollButton,\n\t\tscrollToBottom,\n\t] = useScrollToBottom<HTMLDivElement>();\n\n\treturn (\n\t\t<ScrollArea className=\"flex-1 relative\">\n\t\t\t<div ref={messagesContainerRef}>\n\t\t\t\t<div className={cn(className, \"min-h-0\")}>{children}</div>\n\t\t\t\t<div\n\t\t\t\t\tref={messagesEndRef}\n\t\t\t\t\tclassName=\"shrink-0 min-w-[24px] min-h-[4px]\"\n\t\t\t\t/>\n\t\t\t</div>\n\t\t\t{showScrollButton && (\n\t\t\t\t<ScrollButton\n\t\t\t\t\tonClick={scrollToBottom}\n\t\t\t\t\talignment={scrollButtonAlignment}\n\t\t\t\t/>\n\t\t\t)}\n\t\t</ScrollArea>\n\t);\n}\n\nChatMessageArea.displayName = \"ChatMessageArea\";\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "hooks/use-scroll-to-bottom.ts",
      "content": "import { type RefObject, useEffect, useRef, useState } from \"react\";\n\nexport function useScrollToBottom<T extends HTMLElement>(): [\n\tRefObject<T>,\n\tRefObject<T>,\n\tboolean,\n\t() => void,\n] {\n\tconst containerRef = useRef<T>(null);\n\tconst endRef = useRef<T>(null);\n\tconst [shouldAutoScroll, setShouldAutoScroll] = useState(true);\n\tconst [showScrollButton, setShowScrollButton] = useState(false);\n\tconst [isTouching, setIsTouching] = useState(false);\n\n\tuseEffect(() => {\n\t\tconst container = containerRef.current;\n\t\tconst end = endRef.current;\n\n\t\tif (container && end) {\n\t\t\t// Find the actual scrollable viewport element (Radix UI ScrollArea Viewport)\n\t\t\tconst scrollViewport = container.closest(\n\t\t\t\t\"[data-radix-scroll-area-viewport]\",\n\t\t\t);\n\n\t\t\tif (!scrollViewport) {\n\t\t\t\tconsole.warn(\"ScrollArea viewport not found\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Handle touch events\n\t\t\tconst handleTouchStart = () => setIsTouching(true);\n\t\t\tconst handleTouchEnd = () => setIsTouching(false);\n\n\t\t\t// Handle scroll events to determine if we should auto-scroll\n\t\t\tconst handleScroll = () => {\n\t\t\t\tif (isTouching) {\n\t\t\t\t\tsetShouldAutoScroll(false);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst { scrollTop, scrollHeight, clientHeight } = scrollViewport;\n\t\t\t\tconst distanceFromBottom = scrollHeight - scrollTop - clientHeight;\n\t\t\t\t// Use a hybrid approach: either within 30px of bottom OR 99.5% scrolled\n\t\t\t\tconst scrollPercentage = (scrollTop + clientHeight) / scrollHeight;\n\t\t\t\tconst isNearBottom =\n\t\t\t\t\tdistanceFromBottom < 30 || scrollPercentage > 0.995;\n\t\t\t\tsetShouldAutoScroll(isNearBottom);\n\t\t\t\tsetShowScrollButton(!isNearBottom);\n\t\t\t};\n\n\t\t\tscrollViewport.addEventListener(\"scroll\", handleScroll);\n\t\t\tscrollViewport.addEventListener(\"touchstart\", handleTouchStart);\n\t\t\tscrollViewport.addEventListener(\"touchend\", handleTouchEnd);\n\n\t\t\tconst observer = new MutationObserver(() => {\n\t\t\t\tif (shouldAutoScroll && !isTouching) {\n\t\t\t\t\tconst scrollViewport = container.closest(\n\t\t\t\t\t\t\"[data-radix-scroll-area-viewport]\",\n\t\t\t\t\t) as HTMLElement;\n\t\t\t\t\t\n\t\t\t\t\tif (scrollViewport) {\n\t\t\t\t\t\tscrollViewport.scrollTo({\n\t\t\t\t\t\t\ttop: scrollViewport.scrollHeight,\n\t\t\t\t\t\t\tbehavior: \"instant\"\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tobserver.observe(container, {\n\t\t\t\tchildList: true,\n\t\t\t\tsubtree: true,\n\t\t\t\tattributes: true,\n\t\t\t\tcharacterData: true,\n\t\t\t});\n\n\t\t\treturn () => {\n\t\t\t\tobserver.disconnect();\n\t\t\t\tscrollViewport.removeEventListener(\"scroll\", handleScroll);\n\t\t\t\tscrollViewport.removeEventListener(\"touchstart\", handleTouchStart);\n\t\t\t\tscrollViewport.removeEventListener(\"touchend\", handleTouchEnd);\n\t\t\t};\n\t\t}\n\t}, [shouldAutoScroll, isTouching]);\n\n\tconst scrollToBottom = () => {\n\t\tconst container = containerRef.current;\n\t\tif (container) {\n\t\t\tconst scrollViewport = container.closest(\n\t\t\t\t\"[data-radix-scroll-area-viewport]\",\n\t\t\t) as HTMLElement;\n\t\t\t\n\t\t\tif (scrollViewport) {\n\t\t\t\tscrollViewport.scrollTo({\n\t\t\t\t\ttop: scrollViewport.scrollHeight,\n\t\t\t\t\tbehavior: \"smooth\"\n\t\t\t\t});\n\t\t\t\tsetShouldAutoScroll(true);\n\t\t\t}\n\t\t}\n\t};\n\n\treturn [containerRef, endRef, showScrollButton, scrollToBottom];\n}\n",
      "type": "registry:hook",
      "target": ""
    }
  ]
}