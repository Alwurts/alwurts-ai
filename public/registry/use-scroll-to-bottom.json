{
  "name": "use-scroll-to-bottom",
  "type": "registry:hook",
  "files": [
    {
      "path": "hooks/use-scroll-to-bottom.ts",
      "content": "import { type RefObject, useEffect, useRef, useState } from \"react\";\n\nexport function useScrollToBottom<T extends HTMLElement>(): [\n\tRefObject<T>,\n\tRefObject<T>,\n\tboolean,\n\t() => void,\n] {\n\tconst containerRef = useRef<T>(null);\n\tconst endRef = useRef<T>(null);\n\tconst [shouldAutoScroll, setShouldAutoScroll] = useState(true);\n\tconst [showScrollButton, setShowScrollButton] = useState(false);\n\tconst [isTouching, setIsTouching] = useState(false);\n\n\tuseEffect(() => {\n\t\tconst container = containerRef.current;\n\t\tconst end = endRef.current;\n\n\t\tif (container && end) {\n\t\t\t// Find the actual scrollable viewport element (Radix UI ScrollArea Viewport)\n\t\t\tconst scrollViewport = container.closest(\n\t\t\t\t\"[data-radix-scroll-area-viewport]\",\n\t\t\t);\n\n\t\t\tif (!scrollViewport) {\n\t\t\t\tconsole.warn(\"ScrollArea viewport not found\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Handle touch events\n\t\t\tconst handleTouchStart = () => setIsTouching(true);\n\t\t\tconst handleTouchEnd = () => setIsTouching(false);\n\n\t\t\t// Handle scroll events to determine if we should auto-scroll\n\t\t\tconst handleScroll = () => {\n\t\t\t\tif (isTouching) {\n\t\t\t\t\tsetShouldAutoScroll(false);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst { scrollTop, scrollHeight, clientHeight } = scrollViewport;\n\t\t\t\tconst distanceFromBottom = scrollHeight - scrollTop - clientHeight;\n\t\t\t\t// Use a hybrid approach: either within 30px of bottom OR 99.5% scrolled\n\t\t\t\tconst scrollPercentage = (scrollTop + clientHeight) / scrollHeight;\n\t\t\t\tconst isNearBottom =\n\t\t\t\t\tdistanceFromBottom < 30 || scrollPercentage > 0.995;\n\t\t\t\tsetShouldAutoScroll(isNearBottom);\n\t\t\t\tsetShowScrollButton(!isNearBottom);\n\t\t\t};\n\n\t\t\tscrollViewport.addEventListener(\"scroll\", handleScroll);\n\t\t\tscrollViewport.addEventListener(\"touchstart\", handleTouchStart);\n\t\t\tscrollViewport.addEventListener(\"touchend\", handleTouchEnd);\n\n\t\t\tconst observer = new MutationObserver(() => {\n\t\t\t\tif (shouldAutoScroll && !isTouching) {\n\t\t\t\t\tconst scrollViewport = container.closest(\n\t\t\t\t\t\t\"[data-radix-scroll-area-viewport]\",\n\t\t\t\t\t) as HTMLElement;\n\t\t\t\t\t\n\t\t\t\t\tif (scrollViewport) {\n\t\t\t\t\t\tscrollViewport.scrollTo({\n\t\t\t\t\t\t\ttop: scrollViewport.scrollHeight,\n\t\t\t\t\t\t\tbehavior: \"instant\"\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tobserver.observe(container, {\n\t\t\t\tchildList: true,\n\t\t\t\tsubtree: true,\n\t\t\t\tattributes: true,\n\t\t\t\tcharacterData: true,\n\t\t\t});\n\n\t\t\treturn () => {\n\t\t\t\tobserver.disconnect();\n\t\t\t\tscrollViewport.removeEventListener(\"scroll\", handleScroll);\n\t\t\t\tscrollViewport.removeEventListener(\"touchstart\", handleTouchStart);\n\t\t\t\tscrollViewport.removeEventListener(\"touchend\", handleTouchEnd);\n\t\t\t};\n\t\t}\n\t}, [shouldAutoScroll, isTouching]);\n\n\tconst scrollToBottom = () => {\n\t\tconst container = containerRef.current;\n\t\tif (container) {\n\t\t\tconst scrollViewport = container.closest(\n\t\t\t\t\"[data-radix-scroll-area-viewport]\",\n\t\t\t) as HTMLElement;\n\t\t\t\n\t\t\tif (scrollViewport) {\n\t\t\t\tscrollViewport.scrollTo({\n\t\t\t\t\ttop: scrollViewport.scrollHeight,\n\t\t\t\t\tbehavior: \"smooth\"\n\t\t\t\t});\n\t\t\t\tsetShouldAutoScroll(true);\n\t\t\t}\n\t\t}\n\t};\n\n\treturn [containerRef, endRef, showScrollButton, scrollToBottom];\n}\n",
      "type": "registry:hook",
      "target": ""
    }
  ]
}